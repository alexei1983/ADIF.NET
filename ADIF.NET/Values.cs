using System;
using System.Globalization;
using System.Linq;
using System.Collections.Generic;
using System.Reflection;
using ADIF.NET.Attributes;
using ADIF.NET.Helpers;
using ADIF.NET.Tags;
using ADIF.NET.Types;

namespace ADIF.NET {

  public static class Values {

    /// <summary>
    /// ADIF date format.
    /// </summary>
    public const string ADIF_DATE_FORMAT = "yyyyMMdd";

    /// <summary>
    /// Long ADIF time format.
    /// </summary>
    public const string ADIF_TIME_FORMAT_LONG = "HHmmss";

    /// <summary>
    /// Short ADIF time format.
    /// </summary>
    public const string ADIF_TIME_FORMAT_SHORT = "HHmm";

    /// <summary>
    /// Character that represents the opening of an ADIF tag.
    /// </summary>
    public const char TAG_OPENING = '<';

    /// <summary>
    /// Character that represents the closing of an ADIF tag.
    /// </summary>
    public const char TAG_CLOSING = '>';

    /// <summary>
    /// Character that represents the start of a comment in an ADIF file.
    /// </summary>
    public const char COMMENT_INDICATOR = '#';

    /// <summary>
    /// Newline character.
    /// </summary>
    public const char NEWLINE = '\n';

    /// <summary>
    /// Carriage return character.
    /// </summary>
    public const char CARRIAGE_RETURN = '\r';

    /// <summary>
    /// Ampersand character.
    /// </summary>
    public const char AMPERSAND = '&';

    /// <summary>
    /// Default character to delimit list items in ADIF.
    /// </summary>
    public const char LIST_DELIMITER = COLON;

    /// <summary>
    /// Character that indicates the start of an ADIF tag length.
    /// </summary>
    public const char VALUE_LENGTH_CHAR = COLON;

    /// <summary>
    /// Default character to delimit values in an ADIF list.
    /// </summary>
    public const char VALUE_SEPARATOR = COMMA;

    /// <summary>
    /// Comma character.
    /// </summary>
    public const char COMMA = ',';

    /// <summary>
    /// Tab character.
    /// </summary>
    public const char TAB = '\t';

    /// <summary>
    /// Colon character.
    /// </summary>
    public const char COLON = ':';

    /// <summary>
    /// Opening curly brace character.
    /// </summary>
    public const char CURLY_BRACE_OPEN = '{';

    /// <summary>
    /// Closing curly brace character.
    /// </summary>
    public const char CURLY_BRACE_CLOSE = '}';

    /// <summary>
    /// Underscore character.
    /// </summary>
    public const char UNDERSCORE = '_';

    /// <summary>
    /// Default program ID used in generated ADIF files.
    /// </summary>
    public const string DEFAULT_PROGRAM_ID = "ADIFNET";

    /// <summary>
    /// Default header text on the first line of an ADIF file.
    /// </summary>
    public const string DEFAULT_ADIF_HEADER_TEXT = "ADIF generated by " + DEFAULT_PROGRAM_ID;

    /// <summary>
    /// String representing a true boolean value.
    /// </summary>
    public const string ADIF_BOOLEAN_TRUE = "Y";

    /// <summary>
    /// String representing a false boolean value.
    /// </summary>
    public const string ADIF_BOOLEAN_FALSE = "N";

    /// <summary>
    /// Display string for a true boolean value.
    /// </summary>
    public const string ADIF_BOOLEAN_TRUE_DISPLAY = "Yes";

    /// <summary>
    /// Display string for a false boolean value.
    /// </summary>
    public const string ADIF_BOOLEAN_FALSE_DISPLAY = "No";
    
    /// <summary>
    /// 
    /// </summary>
    public const string ADIF_NET_CONFIG_FILE_NAME = "adifnet.properties";

    /// <summary>
    /// Regex used to match the ADIF SOTARef data type.
    /// </summary>
    public const string SOTA_REF_REGEX = @"[a-zA-Z0-9]{1,8}\/[a-zA-Z]{2}\-([0-9][0-9][1-9]|[0-9][1-9][0-9]|[1-9][0-9][0-9])";

    /// <summary>
    /// Regex used to match callsigns.
    /// </summary>
    public const string CALLSIGN_REGEX = @"^((\d|[A-Z])+\/)?((\d|[A-Z]){3,})(\/(\d|[A-Z])+)?(\/(\d|[A-Z])+)?$";

    /// <summary>
    /// ADIF version.
    /// </summary>
    public static readonly Version ADIFVersion = new Version(3, 1, 0);

    /// <summary>
    /// The current version of ADIF.NET
    /// </summary>
    public static readonly Version ProgramVersion = Assembly.GetExecutingAssembly().GetName().Version;

    /// <summary>
    /// QSO upload status enumeration.
    /// </summary>
    public static readonly ADIFEnumeration QSOUploadStatuses;

    /// <summary>
    /// QSO completion status enumeration.
    /// </summary>
    public static readonly ADIFEnumeration QSOCompleteStatuses;

    /// <summary>
    /// QSL via enumeration.
    /// </summary>
    public static readonly ADIFEnumeration Via;

    /// <summary>
    /// Antenna path enumeration.
    /// </summary>
    public static readonly ADIFEnumeration AntennaPaths;

    /// <summary>
    /// QSL medium enumeration.
    /// </summary>
    public static readonly ADIFEnumeration QSLMediums;

    /// <summary>
    /// Continent enumeration.
    /// </summary>
    public static readonly ADIFEnumeration Continents;

    /// <summary>
    /// eSQL sent status enumeration.
    /// </summary>
    public static readonly ADIFEnumeration EQSLSentStatuses;

    /// <summary>
    /// eQSL received status enumeration.
    /// </summary>
    public static readonly ADIFEnumeration EQSLReceivedStatuses;

    /// <summary>
    /// Propagation mode enumeration.
    /// </summary>
    public static readonly ADIFEnumeration PropagationModes;

    /// <summary>
    /// ARRL section enumeration.
    /// </summary>
    public static readonly ADIFEnumeration ARRLSections;

    /// <summary>
    /// Award enumeration.
    /// </summary>
    public static readonly ADIFEnumeration Awards;

    /// <summary>
    /// Mode enumeration.
    /// </summary>
    public static readonly ADIFEnumeration Modes;

    /// <summary>
    /// Submode enumeration.
    /// </summary>
    public static readonly ADIFEnumeration Submodes;

    /// <summary>
    /// Sponsored award prefix enumeration.
    /// </summary>
    public static readonly ADIFEnumeration SponsoredAwardPrefixes;

    /// <summary>
    /// Country code enumeration.
    /// </summary>
    public static readonly ADIFEnumeration CountryCodes;

    /// <summary>
    /// Contest enumeration.
    /// </summary>
    public static readonly ADIFEnumeration Contests;

    /// <summary>
    /// Amateur radio band enumeration
    /// </summary>
    public static readonly ADIFEnumeration Bands;

    /// <summary>
    /// Credit enumeration.
    /// </summary>
    public static readonly ADIFEnumeration Credits;

    /// <summary>
    /// QSL received statuses.
    /// </summary>
    public static readonly ADIFEnumeration QSLReceivedStatuses;

    /// <summary>
    /// QSL sent statuses.
    /// </summary>
    public static readonly ADIFEnumeration QSLSentStatuses;

    /// <summary>
    /// Boolean values.
    /// </summary>
    public static readonly ADIFEnumeration BooleanValues;

    /// <summary>
    /// 
    /// </summary>
    public static readonly ADIFEnumeration DARCDOKs;

    /// <summary>
    /// Primary administrative subdivisions.
    /// </summary>
    public static readonly ADIFEnumeration PrimarySubdivisions;

    /// <summary>
    /// Secondary administrative subdivisions.
    /// </summary>
    public static readonly ADIFEnumeration SecondarySubdivisions;

    /// <summary>
    /// 
    /// </summary>
    public static readonly ADIFEnumeration Regions;

    /// <summary>
    /// User configuration for ADIF.NET
    /// </summary>
    public static readonly Configuration Configuration;


    /// <summary>
    /// Instantiates the static data fields for the class.
    /// </summary>
    static Values()
    {
      QSOUploadStatuses = ADIFEnumeration.Get("QSOUploadStatus");
      QSOCompleteStatuses = ADIFEnumeration.Get("QSOCompleteStatus");
      Via = ADIFEnumeration.Get("Via");
      AntennaPaths = ADIFEnumeration.Get("AntennaPath");
      QSLMediums = ADIFEnumeration.Get("QSLMedium");
      Continents = ADIFEnumeration.Get("Continent");
      EQSLSentStatuses = ADIFEnumeration.Get("EQSLSentStatus");
      EQSLReceivedStatuses = ADIFEnumeration.Get("EQSLReceivedStatus");
      PropagationModes = ADIFEnumeration.Get("PropagationMode");
      ARRLSections = ADIFEnumeration.Get("ARRLSection");
      Awards = ADIFEnumeration.Get("Award");
      Modes = ADIFEnumeration.Get("Mode");
      Submodes = ADIFEnumeration.Get("Submode");
      SponsoredAwardPrefixes = ADIFEnumeration.Get("SponsoredAwardPrefix");
      CountryCodes = ADIFEnumeration.Get("DXCC");
      Contests = ADIFEnumeration.Get("ContestID");
      Bands = ADIFEnumeration.Get("Band");
      Credits = ADIFEnumeration.Get("Credit");
      QSLSentStatuses = ADIFEnumeration.Get("QSLSent");
      QSLReceivedStatuses = ADIFEnumeration.Get("QSLRcvd");
      BooleanValues = ADIFEnumeration.Get(nameof(ADIFBoolean));
      DARCDOKs = ADIFEnumeration.Get("DARCDOK");
      Regions = ADIFEnumeration.Get("Region");
      PrimarySubdivisions = ADIFEnumeration.Get("PrimarySubdivision");
      SecondarySubdivisions = ADIFEnumeration.Get("SecondarySubdivision");
      Configuration = new Configuration();
    }
  }

  /// <summary>
  /// Defines the names of ADIF tags.
  /// </summary>
  public static class TagNames {

    public const string Address = "ADDRESS";
    public const string AddressIntl = "ADDRESS_INTL";
    public const string ADIFVer = "ADIF_VER";
    public const string Age = "AGE";
    public const string AntAz = "ANT_AZ";
    public const string AntEl = "ANT_EL";
    public const string ARRLSect = "ARRL_SECT";
    public const string AntPath = "ANT_PATH";
    public const string AIndex = "A_INDEX";
    public const string AppDef = "APP_";
    public const string AwardSubmitted = "AWARD_SUBMITTED";
    public const string AwardGranted = "AWARD_GRANTED";
    public const string Band = "BAND";
    public const string BandRx = "BAND_RX";
    public const string Call = "CALL";
    public const string Check = "CHECK";
    public const string Class = "CLASS";
    public const string ClubLogQSOUploadDate = "CLUBLOG_QSO_UPLOAD_DATE";
    public const string ClubLogQSOUploadStatus = "CLUBLOG_QSO_UPLOAD_STATUS";
    public const string Cnty = "CNTY";
    public const string Comment = "COMMENT";
    public const string CommentIntl = "COMMENT_INTL";
    public const string Continent = "CONT";
    public const string ContactedOp = "CONTACTED_OP";
    public const string ContestId = "CONTEST_ID";
    public const string Country = "COUNTRY";
    public const string CountryIntl = "COUNTRY_INTL";
    public const string CQZ = "CQZ";
    public const string CreatedTimestamp = "CREATED_TIMESTAMP";
    public const string CreditSubmitted = "CREDIT_SUBMITTED";
    public const string CreditGranted = "CREDIT_GRANTED";
    public const string DARCDOK = "DARC_DOK";
    public const string Distance = "DISTANCE";
    public const string DXCC = "DXCC";
    public const string Email = "EMAIL";
    public const string EqCall = "EQ_CALL";
    public const string EndHeader = "EOH";
    public const string EndRecord = "EOR";
    public const string EQSLReceivedDate = "EQSL_QSLRDATE";
    public const string EQSLSentDate = "EQSL_QSLSDATE";
    public const string EQSLReceivedStatus = "EQSL_QSL_RCVD";
    public const string EQSLSentStatus = "EQSL_QSL_SENT";
    public const string Fists = "FISTS";
    public const string FistsCc = "FISTS_CC";
    public const string ForceInit = "FORCE_INIT";
    public const string Freq = "FREQ";
    public const string FreqRx = "FREQ_RX";
    public const string GridSquare = "GRIDSQUARE";
    public const string GuestOp = "GUEST_OP";
    public const string HrdLogQSOUploadDate = "HRDLOG_QSO_UPLOAD_DATE";
    public const string HrdLogQSOUploadStatus = "HRDLOG_QSO_UPLOAD_STATUS";
    public const string IOTA = "IOTA";
    public const string IOTAIslandId = "IOTA_ISLAND_ID";
    public const string ITUZ = "ITUZ";
    public const string KIndex = "K_INDEX";
    public const string Lat = "LAT";
    public const string Lon = "LON";
    public const string LOTWQSLReceivedDate = "LOTW_QSLRDATE";
    public const string LOTWQSLSentDate = "LOTW_QSLSDATE";
    public const string LOTWQSLRcvdStatus = "LOTW_QSL_RCVD";
    public const string LOTWQSLSentStatus = "LOTW_QSL_SENT";
    public const string MaxBursts = "MAX_BURSTS";
    public const string Mode = "MODE";
    public const string MsShower = "MS_SHOWER";
    public const string MyAntenna = "MY_ANTENNA";
    public const string MyAntennaIntl = "MY_ANTENNA_INTL";
    public const string MyCity = "MY_CITY";
    public const string MyCityIntl = "MY_CITY_INTL";
    public const string MyCnty = "MY_CNTY";
    public const string MyCountry = "MY_COUNTRY";
    public const string MyCountryIntl = "MY_COUNTRY_INTL";
    public const string MyCQZone = "MY_CQ_ZONE";
    public const string MyDXCC = "MY_DXCC";
    public const string MyFists = "MY_FISTS";
    public const string MyGridSquare = "MY_GRIDSQUARE";
    public const string MyIOTA = "MY_IOTA";
    public const string MyIOTAIslandId = "MY_IOTA_ISLAND_ID";
    public const string MyITUZone = "MY_ITU_ZONE";
    public const string MyLat = "MY_LAT";
    public const string MyLon = "MY_LON";
    public const string MyName = "MY_NAME";
    public const string MyNameIntl = "MY_NAME_INTL";
    public const string MyPostalCode = "MY_POSTAL_CODE";
    public const string MyPostalCodeIntl = "MY_POSTAL_CODE_INTL";
    public const string MyRig = "MY_RIG";
    public const string MyRigIntl = "MY_RIG_INTL";
    public const string MySig = "MY_SIG";
    public const string MySigIntl = "MY_SIG_INTL";
    public const string MySigInfo = "MY_SIG_INFO";
    public const string MySigInfoIntl = "MY_SIG_INFO_INTL";
    public const string MySOTARef = "MY_SOTA_REF";
    public const string MyState = "MY_STATE";
    public const string MyStreet = "MY_STREET";
    public const string MyStreetIntl = "MY_STREET_INTL";
    public const string MyUSACACounties = "MY_USACA_COUNTIES";
    public const string MyVUCCGrids = "MY_VUCC_GRIDS";
    public const string Name = "NAME";
    public const string NameIntl = "NAME_INTL";
    public const string Notes = "NOTES";
    public const string NotesIntl = "NOTES_INTL";
    public const string NrBursts = "NR_BURSTS";
    public const string NrPings = "NR_PINGS";
    public const string OwnerCallSign = "OWNER_CALLSIGN";
    public const string Operator = "OPERATOR";
    public const string Pfx = "PFX";
    public const string Precedence = "PRECEDENCE";
    public const string ProgramId = "PROGRAMID";
    public const string ProgramVersion = "PROGRAMVERSION";
    public const string PropMode = "PROP_MODE";
    public const string PublicKey = "PUBLIC_KEY";
    public const string QRZQSOUploadDate = "QRZCOM_QSO_UPLOAD_DATE";
    public const string QRZQSOUploadStatus = "QRZCOM_QSO_UPLOAD_STATUS";
    public const string QSODateOff = "QSO_DATE_OFF";
    public const string QSODate = "QSO_DATE";
    public const string QSLRcvdDate = "QSLRDATE";
    public const string QSLSentDate = "QSLSDATE";
    public const string QSLRcvd = "QSL_RCVD";
    public const string QSLRcvdVia = "QSL_RCVD_VIA";
    public const string QSLSent = "QSL_SENT";
    public const string QSLSentVia = "QSL_SENT_VIA";
    public const string QSLVia = "QSL_VIA";
    public const string QSLMsg = "QSLMSG";
    public const string QSLMsgIntl = "QSLMSG_INTL";
    public const string QSOComplete = "QSO_COMPLETE";
    public const string QSORandom = "QSO_RANDOM";
    public const string QTH = "QTH";
    public const string QTHIntl = "QTH_INTL";
    public const string Region = "REGION";
    public const string Rig = "RIG";
    public const string RigIntl = "RIG_INTL";
    public const string RstRcvd = "RST_RCVD";
    public const string RstSent = "RST_SENT";
    public const string RxPwr = "RX_PWR";
    public const string SatMode = "SAT_MODE";
    public const string SatName = "SAT_NAME";
    public const string Sfi = "SFI";
    public const string Sig = "SIG";
    public const string SigIntl = "SIG_INTL";
    public const string SigInfo = "SIG_INFO";
    public const string SigInfoIntl = "SIG_INFO_INTL";
    public const string SilentKey = "SILENT_KEY";
    public const string SKCC = "SKCC";
    public const string SOTARef = "SOTA_REF";
    public const string Srx = "SRX";
    public const string SrxString = "SRX_STRING";
    public const string State = "STATE";
    public const string StationCallSign = "STATION_CALLSIGN";
    public const string Stx = "STX";
    public const string StxString = "STX_STRING";
    public const string Submode = "SUBMODE";
    public const string SWL = "SWL";
    public const string TenTen = "TEN_TEN";
    public const string TimeOff = "TIME_OFF";
    public const string TimeOn = "TIME_ON";
    public const string TxPwr = "TX_PWR";
    public const string UKSMG = "UKSMG";
    public const string USACACounties = "USACA_COUNTIES";
    public const string UserDef = "USERDEF";
    public const string VEProv = "VE_PROV";
    public const string VUCCGrids = "VUCC_GRIDS";
    public const string Web = "WEB";

    /// <summary>
    /// Retrieves all ADIF tag names.
    /// </summary>
    public static IEnumerable<string> GetTagNames()
    {
      var constants = typeof(TagNames).GetConstants(typeof(string));
      return constants.Select(c => c.GetRawConstantValue().ToString());
    }

    /// <summary>
    /// Determines whether or not the specified string is an ADIF tag name.
    /// </summary>
    /// <param name="name">Name to check.</param>
    public static bool IsTagName(string name)
    {
      var names = GetTagNames().Where(c => c.Equals(name, StringComparison.OrdinalIgnoreCase))?.ToArray();
      return names != null && names.Length > 0;
    }

    /// <summary>
    /// Retrieves all ADIF QSO tag names.
    /// </summary>
    public static IEnumerable<string> GetQSOTagNames()
    {
      var constants = typeof(TagNames).GetConstants(typeof(string));
      return constants.Select(c => c.GetRawConstantValue().ToString())
                      .Where((c) =>
      {
        return !ADIFVer.Equals(c) && !CreatedTimestamp.Equals(c) &&
               !UserDef.Equals(c) && !ProgramId.Equals(c) && !ProgramVersion.Equals(c) &&
               !AppDef.Equals(c);
      });
    }
  }

  /// <summary>
  /// 
  /// </summary>
  public static class ADXValues {

    /// <summary>
    /// The root ADX element.
    /// </summary>
    public const string ADX_ROOT_ELEMENT = "ADX";

    /// <summary>
    /// The RECORDS element in ADX.
    /// </summary>
    public const string ADX_RECORDS_ELEMENT = "RECORDS";

    /// <summary>
    /// The RECORD element in ADX.
    /// </summary>
    public const string ADX_RECORD_ELEMENT = "RECORD";

    /// <summary>
    /// The HEADER element in ADX.
    /// </summary>
    public const string ADX_HEADER_ELEMENT = "HEADER";

    /// <summary>
    /// The ENUM attribute in ADX.
    /// </summary>
    public const string ADX_ENUM_ATTRIBUTE = "ENUM";

    /// <summary>
    /// The RANGE attribute in ADX.
    /// </summary>
    public const string ADX_RANGE_ATTRIBUTE = "RANGE";

    /// <summary>
    /// The FIELDID attribute in ADX.
    /// </summary>
    public const string ADX_FIELDID_ATTRIBUTE = "FIELDID";

    /// <summary>
    /// The TYPE attribute in ADX.
    /// </summary>
    public const string ADX_TYPE_ATTRIBUTE = "TYPE";

    /// <summary>
    /// The PROGRAMID attribute in ADX.
    /// </summary>
    public const string ADX_PROGRAMID_ATTRIBUTE = "PROGRAMID";

    /// <summary>
    /// The APP element in ADX.
    /// </summary>
    public const string ADX_APP_ELEMENT = "APP";

    /// <summary>
    /// The FIELDNAME attribute in ADX.
    /// </summary>
    public const string ADX_FIELDNAME_ATTRIBUTE = "FIELDNAME";
  }

  /// <summary>
  /// Represents an ADIF enumeration.
  /// </summary>
  public class ADIFEnumeration : List<ADIFEnumerationValue> {

    /// <summary>
    /// The enumeration type.
    /// </summary>
    public string Type { get; set; }

    /// <summary>
    /// Creates a new instance of the <see cref="ADIFEnumeration"/> class.
    /// </summary>
    public ADIFEnumeration() { }

    /// <summary>
    /// Creates a new instance of the <see cref="ADIFEnumeration"/> class.
    /// </summary>
    /// <param name="type">The enumeration type.</param>
    public ADIFEnumeration(string type) : this(type, null) { }

    /// <summary>
    /// Creates a new instance of the <see cref="ADIFEnumeration"/> class.
    /// </summary>
    /// <param name="type">The enumeration type.</param>
    /// <param name="values">Values to add to the current enumeration.</param>
    public ADIFEnumeration(string type, params ADIFEnumerationValue[] values)
    {
      this.Type = type;
      if (values != null)
      {
        foreach (var v in values)
        {
          if (v != null)
            this.Add(v);
        }
      }
    }

    /// <summary>
    /// Creates an ADIF enumeration using the custom options in a user-defined tag.
    /// </summary>
    /// <param name="tag">User-defined tag from which to derive the enumeration.</param>
    public static ADIFEnumeration FromUserDefinedTag(UserDefTag tag)
    {
      if (tag == null)
        throw new ArgumentNullException(nameof(tag), "User-defined tag is required.");

      if (tag.CustomOptions != null)
      {
        var enumVal = new ADIFEnumeration(tag.FieldName);
        foreach (var option in tag.CustomOptions)
          enumVal.Add(new ADIFEnumerationValue(option));

        return enumVal;
      }

      return null;
    }

    /// <summary>
    /// Retrieves an ADIF enumeration by type.
    /// </summary>
    /// <param name="type">The enumeration type to retrieve.</param>
    public static ADIFEnumeration Get(string type)
    {
      if (string.IsNullOrEmpty(type))
        throw new ArgumentException("Enumeration type is required.", nameof(type));

      var enumeration = new ADIFEnumeration(type);

      var query = string.Empty;

      if (type == DXCC_ENUM_STRING)
        query = RETRIEVE_DXCC_SQL;
      else if (type == BAND_ENUM_STRING)
        query = RETRIEVE_BANDS_SQL;
      else if (type == CREDIT_ENUM_STRING)
        query = RETRIEVE_CREDIT_SQL;
      else if (type == DARC_DOK_ENUM_STRING)
        query = RETRIEVE_DARC_DOK_SQL;
      else if (type == nameof(ADIFBoolean))
        return new ADIFEnumeration(nameof(ADIFBoolean), new ADIFEnumerationValue(Values.ADIF_BOOLEAN_TRUE, Values.ADIF_BOOLEAN_TRUE_DISPLAY),
                                                        new ADIFEnumerationValue(Values.ADIF_BOOLEAN_FALSE, Values.ADIF_BOOLEAN_FALSE_DISPLAY));
      else if (type == PRIMARY_SUB_ENUM_STRING)
        query = RETRIEVE_PRIMARY_SUB_SQL;
      else if (type == SECONDARY_SUB_ENUM_STRING)
        query = RETRIEVE_SECONDARY_SUB_SQL;
      else
        query = ENUM_RETRIEVE_SQL.Replace("{{TYPE}}", type.Replace("'", "''"));

      var data = SQLiteHelper.Instance.ReadData(query);

      foreach (dynamic d in data)
      {
        var enumVal = new ADIFEnumerationValue(d);
        if (!string.IsNullOrEmpty(enumVal.Code))
          enumeration.Add(enumVal);     
      }

      return enumeration.Count > 0 ? enumeration : null;
    }

    /// <summary>
    /// Determines whether or not the specified value is valid for the current <see cref="ADIFEnumeration"/>.
    /// </summary>
    /// <param name="value">Value to check for validity.</param>
    public bool IsValid(string value)
    {
      if (value == null)
        throw new ArgumentNullException(nameof(value), "Value is required.");

      return !string.IsNullOrEmpty(GetValues().FirstOrDefault(v => value.Equals(v, StringComparison.OrdinalIgnoreCase)));
    }

    /// <summary>
    /// Retrieves a string array of codes for the current <see cref="ADIFEnumeration"/>.
    /// </summary>
    public string[] GetValues()
    {
      return this.Select(v => v.Code).ToArray();
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="code"></param>
    public ADIFEnumerationValue GetValue(string code)
    {
      if (code == null)
        code = string.Empty;

      return this.FirstOrDefault(e => code.Equals(e.Code, StringComparison.OrdinalIgnoreCase));
    }

    /// <summary>
    /// Retrieves the enumeration values belonging to the specified parent.
    /// </summary>
    /// <param name="type">The enumeration type of the parent.</param>
    /// <param name="code">The code of the parent enumeration value.</param>
    public IEnumerable<ADIFEnumerationValue> GetChildren(string type, string code)
    {
      if (string.IsNullOrEmpty(type))
        throw new ArgumentException("Parent type is required.", nameof(type));

      if (string.IsNullOrEmpty(code))
        throw new ArgumentException("Parent code is required.", nameof(code));

      var query = ENUM_RETRIEVE_CHILDREN_SQL;

      if (DXCC_ENUM_STRING.Equals(type))
        query = RETRIEVE_DXCC_CHILDREN_SQL;
      else if (PRIMARY_SUB_ENUM_STRING.Equals(type))
        query = RETRIEVE_PRIMARY_SUB_CHILDREN_SQL;

      var data = SQLiteHelper.Instance.ReadData(query, 
                                                new Dictionary<string, object>() { { "@ParentType", type },
                                                                                   { "@Parent", code } });

      foreach (dynamic d in data)
      {
        var enumVal = new ADIFEnumerationValue(d);
        if (!string.IsNullOrEmpty(enumVal.Code))
          yield return enumVal;
      }
    }
  
    const string ENUM_RETRIEVE_SQL = "SELECT Code, DisplayName, ImportOnly, Legacy, Parent, ParentType FROM \"Enumerations\" WHERE Type = '{{TYPE}}' ORDER BY DisplayName, Code";
    const string RETRIEVE_DXCC_SQL = "SELECT Code, Name AS DisplayName, Deleted AS ImportOnly, Deleted AS Legacy FROM \"CountryCodes\" ORDER BY Name, Code";
    const string RETRIEVE_BANDS_SQL = "SELECT Name AS Code, Name AS DisplayName, 0 AS Legacy, 0 AS ImportOnly FROM \"Bands\"";
    const string RETRIEVE_CREDIT_SQL = "SELECT CreditFor AS Code, Sponsor || ' - ' || Award AS DisplayName, 0 AS Legacy, 0 AS ImportOnly FROM \"Credits\" ORDER BY CreditFor";
    const string RETRIEVE_DARC_DOK_SQL = "SELECT Code, District || ' - ' || Dok AS DisplayName, 0 AS Legacy, 0 AS ImportOnly FROM \"DarcDok\" ORDER BY Code";
    const string ENUM_RETRIEVE_CHILDREN_SQL = "SELECT Code, DisplayName, ImportOnly, Legacy, Parent, ParentType FROM \"Enumerations\" WHERE ParentType = @ParentType AND Parent = @Parent ORDER BY DisplayName, Code";
    const string RETRIEVE_DXCC_CHILDREN_SQL = "SELECT Code, Name AS DisplayName, Deprecated AS ImportOnly, Deprecated AS Legacy, CAST(CountryCode AS TEXT) AS Parent, '" + DXCC_ENUM_STRING + "' AS ParentType FROM \"PrimaryAdminSubdivisions\" WHERE CAST(CountryCode AS TEXT) = @Parent AND '" + DXCC_ENUM_STRING + "' = @ParentType";
    const string RETRIEVE_PRIMARY_SUB_CHILDREN_SQL = "SELECT Code, Name AS DisplayName, Deleted AS ImportOnly, Deleted AS Legacy, PrimarySubdivisionCode AS Parent, '" + PRIMARY_SUB_ENUM_STRING + "' AS ParentType FROM \"SecondaryAdminSubdivisions\" WHERE PrimarySubdivisionCode = @Parent AND '" + PRIMARY_SUB_ENUM_STRING + "' = @ParentType AND CAST(CountryCode AS TEXT) = @CountryCode";
    const string RETRIEVE_PRIMARY_SUB_SQL = "SELECT Code, Name AS DisplayName, Deprecated AS ImportOnly, Deprecated AS Legacy, CAST(CountryCode AS TEXT) AS Parent, '" + DXCC_ENUM_STRING + "' AS ParentType FROM \"PrimaryAdminSubdivisions\" ORDER BY CountryCode, Name, Code";
    const string RETRIEVE_SECONDARY_SUB_SQL = "SELECT s.Code, s.Name AS DisplayName, s.Deleted AS ImportOnly, s.Deleted AS Legacy, s.PrimarySubdivisionCode AS Parent, '" + PRIMARY_SUB_ENUM_STRING + "' AS ParentType FROM \"SecondaryAdminSubdivisions\" s ORDER BY s.CountryCode, s.PrimarySubdivisionCode, s.Name, s.Code" ;
    const string CREDIT_ENUM_STRING = "Credit";
    const string BAND_ENUM_STRING = "Band";
    const string DXCC_ENUM_STRING = "DXCC";
    const string DARC_DOK_ENUM_STRING = "DARCDOK";
    const string PRIMARY_SUB_ENUM_STRING = "PrimarySubdivision";
    const string SECONDARY_SUB_ENUM_STRING = "SecondarySubdivision";
  }

  /// <summary>
  /// Represents a value in an ADIF enumeration.
  /// </summary>
  public class ADIFEnumerationValue : IFormattable {

    /// <summary>
    /// The code for the enumeration value.
    /// </summary>
    public string Code { get; set; }

    /// <summary>
    /// The display name of the enumeration value.
    /// </summary>
    public string DisplayName { get; set; }

    /// <summary>
    /// Whether or not the enumeration value is only valid on import.
    /// </summary>
    public bool ImportOnly { get; set; }

    /// <summary>
    /// Whether or not the enumeration value is a legacy value.
    /// </summary>
    public bool Legacy { get; set; }

    /// <summary>
    /// The parent code for the enumeration value.
    /// </summary>
    public string Parent { get; set; }

    /// <summary>
    /// The enumeration type of the parent.
    /// </summary>
    public string ParentType { get; set; }

    /// <summary>
    /// Creates a new instance of the <see cref="ADIFEnumerationValue"/> class.
    /// </summary>
    /// <param name="code">The code for the enumeration value.</param>
    public ADIFEnumerationValue(string code) : this(code, null) { }

    /// <summary>
    /// Creates a new instance of the <see cref="ADIFEnumerationValue"/> class.
    /// </summary>
    /// <param name="code">The code for the enumeration value.</param>
    /// <param name="displayName">The display name of the enumeration value.</param>
    public ADIFEnumerationValue(string code, string displayName) : this(code, displayName, false, false, null, null) { }

    /// <summary>
    /// Creates a new instance of the <see cref="ADIFEnumerationValue"/> class.
    /// </summary>
    /// <param name="code">The code for the enumeration value.</param>
    /// <param name="displayName">The display name of the enumeration value.</param>
    /// <param name="importOnly">Whether or not the enumeration value is only valid on import.</param>
    /// <param name="legacy">Whether or not the enumeration value is a legacy value.</param>
    /// <param name="parent">The parent code for the enumeration value.</param>
    public ADIFEnumerationValue(string code, string displayName, bool importOnly, bool legacy, string parent = null, string parentType = null)
    {
      this.DisplayName = displayName;
      this.Code = code;
      this.ImportOnly = importOnly;
      this.Legacy = legacy;
      this.Parent = parent;
      this.ParentType = parentType;
    }

    /// <summary>
    /// Creates a new instance of the <see cref="ADIFEnumerationValue"/> class.
    /// </summary>
    /// <param name="value">Dynamic object representing the enumeration value.</param>
    public ADIFEnumerationValue(dynamic value)
    {
      if (value is IDictionary<string, object> dict)
      {
        if (dict.ContainsKey(nameof(DisplayName)) && dict[nameof(DisplayName)] is string name)
          this.DisplayName = name;

        if (dict.ContainsKey(nameof(Code)))
        {
          if (dict[nameof(Code)] is string code)
            this.Code = code;
          else if (dict[nameof(Code)] is int intCode)
            this.Code = intCode.ToString();
          else if (dict[nameof(Code)] is double dblCode)
            this.Code = dblCode.ToString();
          else if (dict[nameof(Code)] is long lngCode)
            this.Code = lngCode.ToString();
        }

        if (dict.ContainsKey(nameof(ImportOnly)))
        {
          if (dict[nameof(ImportOnly)] is bool importOnly)
            this.ImportOnly = importOnly;
          else if (dict[nameof(ImportOnly)] is int intImportOnly)
            this.ImportOnly = intImportOnly == 1;
          else if (dict[nameof(ImportOnly)] is double dblImportOnly)
            this.ImportOnly = dblImportOnly == 1;
          else if (dict[nameof(ImportOnly)] is long lngImportOnly)
            this.ImportOnly = lngImportOnly == 1;
        }

        if (dict.ContainsKey(nameof(Legacy)))
        {
          if (dict[nameof(Legacy)] is bool importOnly)
            this.Legacy = importOnly;
          else if (dict[nameof(Legacy)] is int intLegacy)
            this.Legacy = intLegacy == 1;
          else if (dict[nameof(Legacy)] is double dblLegacy)
            this.Legacy = dblLegacy == 1;
          else if (dict[nameof(Legacy)] is long lngLegacy)
            this.Legacy = lngLegacy == 1;
        }

        if (dict.ContainsKey(nameof(Parent)) && dict[nameof(Parent)] is string parent)
          this.Parent = parent;

        if (dict.ContainsKey(nameof(ParentType)) && dict[nameof(ParentType)] is string parentType)
          this.ParentType = parentType;
      }
    }

    /// <summary>
    /// Returns a string representation of the current <see cref="ADIFEnumerationValue"/>.
    /// </summary>
    public override string ToString()
    {
      return ToString("G", CultureInfo.CurrentCulture);
    }

    /// <summary>
    /// Returns a string representation of the current <see cref="ADIFEnumerationValue"/>.
    /// </summary>
    /// <param name="format">Format string.</param>
    public string ToString(string format)
    {
      return ToString(format, CultureInfo.CurrentCulture);
    }

    /// <summary>
    /// Returns a string representation of the current <see cref="ADIFEnumerationValue"/>.
    /// </summary>
    /// <param name="format">Format string.</param>
    /// <param name="provider">Culture-specific format provider.</param>
    public string ToString(string format, IFormatProvider provider)
    {
      if (string.IsNullOrEmpty(format))
        format = "G";

      if (provider == null)
        provider = CultureInfo.CurrentCulture;

      switch (format)
      {
        case "G":
        case "g":
          return ToString("E", provider);

        case "C":
          return Code ?? string.Empty;

        case "N":
          return DisplayName ?? string.Empty;

        case "I":
          return ImportOnly.ToString();

        case "L":
          return Legacy.ToString();

        case "E":
          return !string.IsNullOrEmpty(Code) && !string.IsNullOrEmpty(DisplayName) ?
            $"{ToString("C", provider)} - {ToString("N", provider)}" :
            !string.IsNullOrEmpty(DisplayName) ? ToString("N", provider) :
            !string.IsNullOrEmpty(Code) ? ToString("C", provider) :
            string.Empty;

        case "e":
          return !string.IsNullOrEmpty(Code) && !string.IsNullOrEmpty(DisplayName) ?
            $"{ToString("N", provider)} - {ToString("C", provider)}" :
            !string.IsNullOrEmpty(DisplayName) ? ToString("N", provider) :
            !string.IsNullOrEmpty(Code) ? ToString("C", provider) :
            string.Empty;

        default:
          throw new FormatException($"Format string '{format}' is not valid.");
      }
    }

  }

  [Enumeration]
  public static class DataTypes {

    public const string AwardList = "A";

    public const string CreditList = "C";

    public const string SponsoredAwardList = "P";

    public const string Boolean = "B";

    public const string Digit = "N";

    public const string Number = "N";

    public const string Character = "S";

    public const string IntlCharacter = "I";

    public const string Date = "D";

    public const string Time = "T";

    public const string String = "S";

    public const string IntlString = "I";

    public const string MultilineString = "M";

    public const string IntlMultilineString = "G";

    public const string Enumeration = "E";

    public const string Location = "L";
  }

  /// <summary>
  /// 
  /// </summary>
  public class DataTypeNames {

    /// <summary>
    /// A comma-delimited list of members of the ADIF Award enumeration.
    /// </summary>
    public const string AwardList = "AwardList";

    /// <summary>
    /// A comma-delimited list where each list item is either: a member of the ADIF Credit enumeration or a member of the 
    /// ADIF Credit enumeration followed by a colon and an ampersand-delimited list of members of the ADIF QSL_Medium enumeration.
    /// </summary>
    public const string CreditList = "CreditList";

    /// <summary>
    /// A comma-delimited list of members of the ADIF Sponsored_Award enumeration.
    /// </summary>
    public const string SponsoredAwardList = "SponsoredAwardList";

    /// <summary>
    /// An ADIF boolean value where <see cref="true"/> is represented by 'Y' or 'y' and <see cref="false"/> is 
    /// represented by 'N' or 'n'.
    /// </summary>
    public const string Boolean = "Boolean";

    /// <summary>
    /// An ASCII character whose code lies in the range of 48 through 57, inclusive.
    /// </summary>
    public const string Digit = "Digit";

    /// <summary>
    /// A sequence of one or more Digits representing a decimal number, optionally preceded by a minus sign and optionally 
    /// including a single decimal point.
    /// </summary>
    public const string Number = "Number";

    /// <summary>
    /// An ASCII character whose code lies in the range of 32 through 126, inclusive.
    /// </summary>
    public const string Character = "Character";

    /// <summary>
    /// A Unicode character (encoded with UTF-8) excluding line break CR (code 13) and LF (code 10) characters.
    /// </summary>
    public const string IntlCharacter = "IntlCharacter";

    /// <summary>
    /// ADIF Date type consisting of 8 Digits representing a UTC date in YYYYMMDD format.
    /// </summary>
    public const string Date = "Date";

    /// <summary>
    /// ADIF Time type consisting of 6 Digits representing a UTC time in HHMMSS format or 4 Digits 
    /// representing a UTC time in HHMM format.
    /// </summary>
    public const string Time = "Time";

    /// <summary>
    /// ADIF String type consisting of a sequence of Characters.
    /// </summary>
    public const string String = "String";

    /// <summary>
    /// ADIF IntlString type consisting of a sequence of International Characters. 
    /// </summary>
    public const string IntlString = "IntlString";

    /// <summary>
    /// ADIF MultilineString type consisting of a sequence of Characters and line-breaks, where a line break is an ASCII CR (code 13) 
    /// followed immediately by an ASCII LF (code 10).
    /// </summary>
    public const string MultilineString = "MultilineString";

    /// <summary>
    /// ADIF IntlMultilineString type consisting of a sequence of International Characters and line breaks. 
    /// </summary>
    public const string IntlMultilineString = "IntlMultilineString";

    /// <summary>
    /// ADIF Enumeration type consisting of an explicit list of legal case-insensitive values represented in ASCII set 
    /// forth in set notation, e.g. {A, B, C, D}, or defined in a table.
    /// </summary>
    public const string Enumeration = "Enumeration";

    /// <summary>
    /// ADIF Location type consisting of a sequence of 11 characters representing a latitude or longitude in XDDD MM.MMM format, 
    /// where X is a directional character from the set {E, W, N, S}, DDD is a 3-digit degrees specifier, where 
    /// 0 &lt;= DDD &lt;= 180, and MM.MMM is an unsigned Number minutes specifier with its decimal point 
    /// in the third position, where 00.000 &lt;= MM.MMM &lt;= 59.999. 
    /// </summary>
    public const string Location = "Location";

    /// <summary>
    /// ADIF GridSquare type consisting of a case-insensitive 2-character, 4-character, 6-character, or 8-character Maidenhead locator.
    /// </summary>
    public const string GridSquare = "GridSquare";

    /// <summary>
    /// ADIF GridSquareList type consisting of a comma-delimited list of <see cref="GridSquare"/> items.
    /// </summary>
    public const string GridSquareList = "GridSquareList";

    /// <summary>
    /// ADIF PositiveInteger type: an unsigned sequence of one or more <see cref="Digit"/>s representing a decimal 
    /// integer that has a value greater than 0.
    /// </summary>
    public const string PositiveInteger = "PositiveInteger";

    /// <summary>
    /// ADIF SecondarySubdivisionList type: a colon-delimited list of two or more members of the ADIF Secondary_Administrative_Subdivision enumeration.
    /// </summary>
    public const string SecondarySubdivisionList = "SecondarySubdivisionList";

    /// <summary>
    /// ADIF SOTARef type: a sequence of <see cref="Character"/>s representing an International SOTA Reference.
    /// </summary>
    public const string SOTARef = "SOTARef";

    /// <summary>
    /// ADIF IOTARefNo type: an IOTA designator, in format CC-XXX, where CC is a member of the ADIF Continent enumeration
    /// and XXX is the island group designator, where 1 &lt;= XXX &lt;= 999 with leading zeros.
    /// </summary>
    public const string IOTARefNo = "IOTARefNo";

    /// <summary>
    /// ADIF Integer type: a sequence of one or more <see cref="Digit"/>s representing a decimal integer, optionally preceded 
    /// by a minus sign (ASCII code 45).
    /// </summary>
    public const string Integer = "Integer";
  }

  /// <summary>
  /// Represents an amateur radio band.
  /// </summary>
  public class Band {

    /// <summary>
    /// The name of the band.
    /// </summary>
    public string Name { get; set; }

    /// <summary>
    /// The upper frequency of the band.
    /// </summary>
    public double UpperFrequency { get; set; }

    /// <summary>
    /// The lower frequency of the band.
    /// </summary>
    public double LowerFrequency { get; set; }

    /// <summary>
    /// Creates a new instance of the <see cref="Band"/> class.
    /// </summary>
    /// <param name="value">Value from the database.</param>
    public Band(dynamic value)
    {
      if (value is IDictionary<string, object> dict)
      {
        if (dict.ContainsKey(nameof(Name)) && dict[nameof(Name)] is string name)
          this.Name = name;

        if (dict.ContainsKey(nameof(UpperFrequency)) && dict[nameof(UpperFrequency)] is double upperFrequency)
          this.UpperFrequency = upperFrequency;

        if (dict.ContainsKey(nameof(LowerFrequency)) && dict[nameof(LowerFrequency)] is double lowerFrequency)
          this.LowerFrequency = lowerFrequency;
      }
    }

    /// <summary>
    /// Retrieves all amateur radio bands.
    /// </summary>
    public static List<Band> Get()
    {
      var bands = new List<Band>();

      var data = SQLiteHelper.Instance.ReadData(GET_BANDS_SQL);
      foreach (var d in data)
      {
        var band = new Band(d);
        if (band != null)
          bands.Add(band);
      }

      return bands;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="frequency"></param>
    public static bool IsAmateurFrequency(double frequency)
    {
      var data = SQLiteHelper.Instance.ReadData(VALIDATE_FREQUENCY_SQL,
                                                new Dictionary<string, object>() { { "@Frequency", frequency } });
      return data.Count > 0;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="frequency"></param>
    public static Band Get(double frequency)
    {
      var data = SQLiteHelper.Instance.ReadData(VALIDATE_FREQUENCY_SQL,
                                                new Dictionary<string, object>() { { "@Frequency", frequency } });
      if (data.Count > 0)
        return new Band(data[0]);

      return null;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="band"></param>
    /// <param name="frequency"></param>
    /// <param name="itu"></param>
    /// <returns></returns>
    public static bool IsFrequencyInBand(string band, double frequency)
    {
      var data = SQLiteHelper.Instance.ReadData(VALIDATE_FREQUENCY_BAND_SQL, 
                                                new Dictionary<string, object>() { { "@Frequency", frequency },
                                                                                   { "@Name", band } });
      return data.Count > 0;
    }

    const string GET_UPPER_FREQENCY_SQL = "SELECT UpperFrequency FROM \"Bands\" WHERE Name = @Name";
    const string GET_LOWER_FREQENCY_SQL = "SELECT LowerFrequency FROM \"Bands\" WHERE Name = @Name";
    const string GET_BANDS_SQL = "SELECT Name, LowerFrequency, UpperFrequency FROM \"Bands\"";
    const string VALIDATE_FREQUENCY_SQL = "SELECT Name, LowerFrequency, UpperFrequency FROM \"Bands\" WHERE @Frequency >= LowerFrequency AND @Frequency <= UpperFrequency";
    const string VALIDATE_FREQUENCY_BAND_SQL = "SELECT Name, LowerFrequency, UpperFrequency FROM \"Bands\" WHERE @Frequency >= LowerFrequency AND @Frequency <= UpperFrequency AND Name = @Name";
  }


}
